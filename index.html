<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å§¿å‹¢åˆ¤å®šï¼‹YouTubeéŸ³ã‚ã‚Šå†ç”Ÿ</title>
  <style>
    :root { --w: 240px; --h: 320px; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "...", Arial, "Noto Sans JP", "Apple Color Emoji", "Segoe UI Emoji";
      font-size: 18px;
      margin: 0;
      color: #111;
      background: #fafafa;
    }
    header {
      padding: 12px 16px;
      background: #fff;
      border-bottom: 1px solid #eee;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    h1 { font-size: 20px; margin: 0; }
  
    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 12px;
    }
    @media (min-width: 900px) {
      main {
        grid-template-columns: 2fr 1.4fr;
        align-items: flex-start;
      }
    }

    .panel {
      background: #fff;
      border-radius: 12px;
      padding: 12px 14px;
      box-shadow: 0 1px 3px rgba(15, 23, 42, 0.08);
      border: 1px solid #e5e7eb;
    }
    .panel h2 {
      margin: 0 0 8px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .panel h2 span.icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: #eff6ff;
      color: #2563eb;
      font-size: 14px;
    }
    .panel p {
      margin: 0 0 6px;
      line-height: 1.5;
      font-size: 14px;
      color: #4b5563;
    }
    .panel .hint {
      font-size: 13px;
      color: #6b7280;
      margin-top: 4px;
    }
    .panel .hint strong {
      color: #2563eb;
    }
    .panel + .panel {
      margin-top: 8px;
    }

    .stage {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    button {
      font: inherit;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #f9fafb;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      min-width: 60px;
      justify-content: center;
    }
    button.primary {
      background: #2563eb;
      border-color: #1d4ed8;
      color: #fff;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      background: #eff6ff;
      color: #1d4ed8;
      border: 1px solid #bfdbfe;
    }

    #warning {
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 14px;
      margin-bottom: 6px;
      text-align: center;
      border: 1px solid transparent;
    }
    #warning.ok {
      background: #ecfdf3;
      color: #166534;
      border-color: #bbf7d0;
    }
    #warning.bad {
      background: #fef2f2;
      color: #b91c1c;
      border-color: #fecaca;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
    }
    .row > div {
      flex: 1 1 150px;
    }

    #output {
      white-space: pre;
      font-size: 13px;
      background: #0f172a;
      color: #e5e7eb;
      border-radius: 8px;
      padding: 6px 8px;
      border: 1px solid #1f2937;
      min-height: 90px;
      box-sizing: border-box;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .pair {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      flex-direction: row;
    }
    video, canvas {
      transform: scaleX(-1);
      width: var(--w);
      height: var(--h);
      border: 1px solid #ddd;
      border-radius: 10px;
      background: #111827;
      object-fit: cover;
    }
    @media (max-width: 600px) {
      :root { --w: min(42vw, 210px); --h: min(56vw, 280px); }
      .pair {
        flex-direction: row;
      }
    }

    #logStatus {
      font-size: 12px;
      color: #6b7280;
      margin-top: 4px;
    }

    .yt-wrap {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .yt-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .yt-row input {
      flex: 1 1 140px;
      min-width: 0;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      font-size: 13px;
      box-sizing: border-box;
    }
    iframe {
      width: 100%;
      min-height: 200px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
    }

    footer {
      font-size: 11px;
      color: #9ca3af;
      text-align: center;
      padding: 8px 12px 16px;
    }
  </style>
</head>
<body>
  <header>
    <h1>ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ³å§¿å‹¢åˆ¤å®šï¼‹YouTubeéŸ³ã‚ã‚Šå†ç”Ÿ</h1>
    <p style="margin:4px 0 0;font-size:13px;color:#6b7280;">
      å‰é¢ã‚«ãƒ¡ãƒ©ï¼‹å‚¾ãã‚»ãƒ³ã‚µã§é¦–ã®å‰å‚¾å§¿å‹¢ã‚’åˆ¤å®šã—ã€<strong>ä¸€å®šæ™‚é–“ç¶šãã¨ãƒ“ãƒ¼ãƒ—éŸ³</strong>ã§çŸ¥ã‚‰ã›ã¾ã™ã€‚
    </p>
  </header>

  <main>
    <!-- å·¦ï¼šã‚«ãƒ¡ãƒ©ï¼‹å§¿å‹¢åˆ¤å®š -->
    <section class="panel">
      <h2>
        <span class="icon">ğŸ“±</span> å§¿å‹¢åˆ¤å®šï¼ˆã‚«ãƒ¡ãƒ©ï¼‹å‚¾ãã‚»ãƒ³ã‚µï¼‰
      </h2>
      <p>
        ã‚¹ãƒãƒ›ã‚’<strong>ç¸¦å‘ã</strong>ã§æŒã¡ã€é¡”ãŒç”»é¢ä¸­å¤®ã‚ãŸã‚Šã«æ˜ ã‚‹ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚
        iOS ã®å ´åˆã€æœ€åˆã«ã€Œã‚¸ãƒ£ã‚¤ãƒ­ãƒ»å‚¾ãã‚»ãƒ³ã‚µã€ã®ä½¿ç”¨è¨±å¯ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒå‡ºã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚
      </p>

      <div class="stage">
        <div class="controls">
          <button id="startBtn" class="primary">æ¸¬å®šé–‹å§‹</button>
          <button id="calibBtn" disabled>æ­£ã—ã„å§¿å‹¢ã®åŸºæº–</button>
          <button id="resetBtn" disabled>è§£é™¤</button>
        </div>
        <div class="pair">
          <video id="video" autoplay muted playsinline></video>
          <canvas id="canvas" width="240" height="320"></canvas>
        </div>
        <div class="badge">
          <span>â„¹ï¸</span><span>é¡”ï¼‹ç«¯æœ«ã®è§’åº¦ã‹ã‚‰ã€Œé¦–ãŒæ›²ãŒã‚Šã™ãã€ã®ç¶™ç¶šã‚’æ¤œå‡º</span>
        </div>
      </div>

      <!-- å§¿å‹¢åˆ¤å®šãƒ»ãƒ­ã‚°ãƒ‘ãƒãƒ«ï¼ˆã‚°ãƒ©ãƒ•å‰Šé™¤æ¸ˆã¿ï¼‰ -->
      <section class="panel">
        <div id="warning" class="ok">æ¸¬å®šå¾…æ©Ÿä¸­</div>
        <div class="row">
          <div>
            <h3>ç¾åœ¨å€¤</h3>
            <div id="output" class="mono">èª­ã¿å–ã‚Šä¸­...</div>
          </div>
        </div>
        <p class="hint">
          ä½¿ã„æ–¹ï¼š<strong>æ¸¬å®šé–‹å§‹</strong> â†’ å€‹äººå·®ãŒå‡ºã‚‹å ´åˆã¯æ­£ã—ã„å§¿å‹¢ã§ <strong>åŸºæº–ãƒœã‚¿ãƒ³</strong> â†’
          ä¸è¦ãªã‚‰ <strong>è§£é™¤</strong>ã€‚iOS ã¯é–‹å§‹æ™‚ã«ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ãŒå¿…è¦ã§ã™ã€‚
        </p>

        <!-- â–¼ ãƒ­ã‚°æ“ä½œUIï¼ˆã‚°ãƒ©ãƒ•ã¯ãªã—ï¼‰ â–¼ -->
        <div class="controls" style="margin-top:6px">
          <button id="logStartBtn">ãƒ­ã‚°é–‹å§‹</button>
          <button id="logStopBtn" disabled>ãƒ­ã‚°åœæ­¢</button>
          <button id="exportCsvBtn">CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
          <button id="clearLogBtn">ãƒ­ã‚°å…¨å‰Šé™¤</button>
        </div>
        <!-- â–² ãƒ­ã‚°æ“ä½œUI â–² -->
      </section>
    </section>

    <!-- â–¼ YouTube éŸ³ã‚ã‚Šå†ç”Ÿãƒ‘ãƒãƒ« â–¼ -->
    <section class="panel">
      <h2><span class="icon">ğŸ§</span> YouTube éŸ³ã‚ã‚Šå†ç”Ÿ</h2>
      <p>
        å¥½ããªå‹•ç”»ã‚’æµã—ãªãŒã‚‰å§¿å‹¢ãƒã‚§ãƒƒã‚¯ãŒã§ãã¾ã™ã€‚<br />
        è‡ªå‹•å†ç”Ÿã¯ãƒ–ãƒ©ã‚¦ã‚¶ã‚„ç«¯æœ«ã®ä»•æ§˜ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
      </p>

      <div class="yt-wrap">
        <div class="yt-row">
          <input id="ytUrl" type="url" placeholder="YouTube ã® URL ã‚’è²¼ã‚Šä»˜ã‘â€¦" />
          <button id="loadYtBtn">èª­ã¿è¾¼ã‚€</button>
        </div>
        <iframe id="ytPlayer" src="" allow="autoplay; encrypted-media" allowfullscreen></iframe>
      </div>
    </section>
  </main>

  <footer>
    ã‚¹ãƒãƒ›ã ã‘ã§å®Œçµã™ã‚‹å®Ÿé¨“ç”¨ãƒ„ãƒ¼ãƒ« / å‚¾ãï¼‹é¡”æ¤œå‡ºã§é¦–å§¿å‹¢ã‚’ç°¡æ˜“è¨ˆæ¸¬
  </footer>

  <!-- MediaPipe & Utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script>
    // ========== è¨­å®š/çŠ¶æ…‹ ==========
    const PARAMS = {
      alphaPitch: 0.25, alphaRoll: 0.25, alphaYdiff: 0.3, alphaNoseZ: 0.25,
      calibYdiff: null, calibNoseZ: null,
      // æ—¢å­˜ã—ãã„å€¤ï¼ˆè·é›¢ãƒ»ãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ç­‰ã§ä½¿ç”¨ï¼‰
      absExitBand: 0.02,
      closeEnter: -0.035, closeExit: -0.015, farEnter: 0.020, farExit: 0.005,
      absCloseEnter: -0.15, absFarEnter: -0.10, absZExitBand: 0.02,
      sustainMs: 10, clearMs: 10,
      // â˜… è¿½åŠ ï¼šè­¦å‘ŠéŸ³è¨­å®š
      beep: { intervalMs: 500, freq: 880, dur: 0.3, gain: 0.08 },
    };

    const video  = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');
    const output = document.getElementById('output');
    const warning = document.getElementById('warning');
    const startBtn = document.getElementById('startBtn');
    const calibBtn = document.getElementById('calibBtn');
    const resetBtn = document.getElementById('resetBtn');

    let rawPitch=0, rawRoll=0;
    let sPitch=0, sRoll=0, sYdiff=null, sNoseZ=null;
    // â˜… ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
    let calibMode = false;
    let calibSamples = [];
    let calibStartTs = 0;

    let faceState = { dir: 'straight', prox: 'é€šå¸¸è·é›¢' };
    let bentState = false;
    let enterStart = null, exitStart  = null;
    let wasDown = false, wasUp = false, wasClose = false, wasFar = false;

    // UIæœ€é©åŒ–
    let lastWarnText = null, lastWarnBad = null;
    let camera = null;
    let lastInferenceTs = 0; // FPSåˆ¶é™

    // â˜… è¿½åŠ ï¼šé¡”æ¤œå‡ºãƒ•ãƒ©ã‚°
    let faceDetected = false;

    // ======== è­¦å‘ŠéŸ³ï¼ˆWeb Audioï¼‰ ========
    let audioCtx = null;
    let beepInterval = null;

    function initAudio() {
      if (audioCtx) return;
      try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      } catch (e) {
        console.warn('AudioContext åˆæœŸåŒ–ã«å¤±æ•—:', e);
        audioCtx = null;
      }
    }

    function playBeep() {
      if (!audioCtx) return;
      const { freq, dur, gain } = PARAMS.beep;
      const osc = audioCtx.createOscillator();
      const g   = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      g.gain.setValueAtTime(gain, audioCtx.currentTime);
      osc.connect(g).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    }

    function startBeepLoop() {
      if (!audioCtx) initAudio();
      if (!audioCtx) return;
      if (beepInterval) return;
      playBeep(); // å…¥ã‚Šã§1å›
      beepInterval = setInterval(() => {
        playBeep();
      }, PARAMS.beep.intervalMs);
    }

    function stopBeepLoop() {
      if (beepInterval) {
        clearInterval(beepInterval);
        beepInterval = null;
      }
    }

    // ========== ã‚»ãƒ³ã‚µãƒ¼ ==========
    function handleOrientation(e){
      rawPitch = (e.beta  ?? 0);
      rawRoll  = (e.gamma ?? 0);

      sPitch = PARAMS.alphaPitch * rawPitch + (1 - PARAMS.alphaPitch) * sPitch;
      sRoll  = PARAMS.alphaRoll  * rawRoll  + (1 - PARAMS.alphaRoll)  * sRoll;
    }

    function startSensor(){
      if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
          if (state === 'granted') {
            window.addEventListener('deviceorientation', handleOrientation);
          } else {
            alert('å‚¾ãã‚»ãƒ³ã‚µã®è¨±å¯ãŒå¾—ã‚‰ã‚Œã¾ã›ã‚“ã§ã—ãŸ');
          }
        }).catch(err => {
          console.error(err);
          alert('ã‚»ãƒ³ã‚µè¨±å¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        });
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }
    }

    // ========== FaceMesh ==========
    const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    faceMesh.onResults(results => {
      // FPSåˆ¶é™ï¼ˆ10fpsï¼‰
      const now = performance.now();
      if (now - lastInferenceTs < 100) return;
      lastInferenceTs = now;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        faceDetected = false; // â˜… é¡”ãªã—
        setWarning(true, 'é¡”ãŒæ¤œå‡ºã§ãã¾ã›ã‚“');
        output.textContent = 'é¡”ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
        return;
      }
      faceDetected = true; // â˜… é¡”ã‚ã‚Š

      const lm = results.multiFaceLandmarks[0];
      const nose = lm[1];
      const chin = lm[152];

      drawPoint(nose, '#22c55e');
      drawPoint(chin, '#2563eb');

      const yDiff = (chin.y - nose.y);
      const noseZ = nose.z;

      sYdiff = (sYdiff == null) ? yDiff : PARAMS.alphaYdiff * yDiff + (1 - PARAMS.alphaYdiff) * sYdiff;
      sNoseZ = (sNoseZ == null) ? noseZ : PARAMS.alphaNoseZ * noseZ + (1 - PARAMS.alphaNoseZ) * sNoseZ;

      // â˜… ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ãªã‚‰ã‚µãƒ³ãƒ—ãƒ«ã‚’è“„ç©
      if (calibMode) {
        calibSamples.push({ y: sYdiff, z: sNoseZ });

        if (now - calibStartTs >= 3000) {
          calibMode = false;

          if (calibSamples.length > 0) {
            const sum = calibSamples.reduce((acc, v) => {
              acc.y += v.y;
              acc.z += v.z;
              return acc;
            }, { y: 0, z: 0 });

            const n = calibSamples.length;
            PARAMS.calibYdiff = sum.y / n;
            PARAMS.calibNoseZ = sum.z / n;

            saveCalibration(PARAMS.calibYdiff, PARAMS.calibNoseZ);
            setWarning(false, 'ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ©ãƒ«å§¿å‹¢ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
          } else {
            setWarning(true, 'ã‚­ãƒ£ãƒªãƒ–ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆã‚µãƒ³ãƒ—ãƒ«0ä»¶ï¼‰');
          }
        }
      }

      // é¡”å‘ã & è·é›¢ã®åˆ†é¡
      const dir = classifyDirection();     // â† combined åˆ¤å®š
      faceState.dir = dir;
      const prox = classifyProximity(sNoseZ);
      faceState.prox = prox;

      // ã‚¹ãƒãƒ›è§’åº¦ã‚‚è€ƒæ…®ã—ãŸé¦–æ›²ãŒã‚Šæœ€çµ‚åˆ¤å®š
      const pitchAbs = Math.abs(sPitch);
      const isBentNow = isBent(faceState.dir, faceState.prox, pitchAbs);
      updateSustain(isBentNow);

      const combined = getCombinedForDebug();
      output.textContent =
        `Pitch: ${sPitch.toFixed(2)}Â°\n` +
        `Roll:  ${sRoll.toFixed(2)}Â°\n` +
        `yDiff(å¹³æ»‘): ${sYdiff.toFixed(4)}\n` +
        `noseZ(å¹³æ»‘): ${sNoseZ.toFixed(4)}\n` +
        `combined(y+z): ${combined.toFixed(4)}\n` +
        `é¡”å‘ã: ${faceState.dir}\n` +
        `é¡”è·é›¢: ${faceState.prox}`;

      // ãƒ­ã‚°è¨˜éŒ²ï¼ˆ1ç§’ç²’åº¦ï¼‰
      addLogSample();
    });

    function drawPoint(normLandmark, color) {
      const x = normLandmark.x * canvas.width;
      const y = normLandmark.y * canvas.height;
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }

    // ========== ã‚«ãƒ¡ãƒ©èµ·å‹• ==========
    function startCamera(){
      if (camera) return;
      camera = new Camera(video, {
        onFrame: async () => { await faceMesh.send({ image: video }); },
        width:  240,
        height: 320
      });
      camera.start();
    }

    // ========== è¡¨ç¤ºç³» ==========
    function setWarning(isBad, text){
      if (text === lastWarnText && isBad === lastWarnBad) return;
      lastWarnText = text;
      lastWarnBad  = isBad;
      warning.textContent = text;
      warning.className = isBad ? 'bad' : 'ok';
    }

    // â˜… é¡”å‘ãï¼šyDiff + noseZ ã§åˆ¤å®šï¼ˆãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ï¼‰
    function classifyDirection() {
      const band = PARAMS.absExitBand ?? 0.02;
      let combined;

      if (PARAMS.calibYdiff != null && PARAMS.calibNoseZ != null){
        combined = (sYdiff - PARAMS.calibYdiff) + (sNoseZ - PARAMS.calibNoseZ);
      } else {
        combined = (sYdiff ?? 0) + (sNoseZ ?? 0);
      }

      if (!wasDown && combined < -0.04) { wasDown = true; wasUp = false; return 'down'; }
      if (wasDown && combined > -0.04 + band) { wasDown = false; }

      if (!wasUp && combined > 0.05) { wasUp = true; wasDown = false; return 'up'; }
      if (wasUp && combined < 0.05 - band) { wasUp = false; }

      return 'straight';
    }

    // â˜… é¡”è·é›¢ï¼šnoseZ å˜ä½“ã§åˆ¤å®šï¼ˆãƒ’ã‚¹ãƒ†ãƒªã‚·ã‚¹ï¼‰
    function classifyProximity(z){
      const band = PARAMS.absZExitBand ?? 0.02;

      if (PARAMS.calibYdiff != null && PARAMS.calibNoseZ != null){
        const dz = z - PARAMS.calibNoseZ;
        if (!wasClose && dz <= PARAMS.closeEnter) { wasClose = true; wasFar = false; return 'é¡”ãŒè¿‘ã„'; }
        if (!wasFar   && dz >= PARAMS.farEnter)   { wasFar   = true; wasClose = false; return 'é¡”ãŒé ã„'; }

        if (wasClose && dz > PARAMS.closeExit + band) { wasClose = false; }
        if (wasFar   && dz < PARAMS.farExit   - band) { wasFar   = false; }

        if (wasClose) return 'é¡”ãŒè¿‘ã„';
        if (wasFar)   return 'é¡”ãŒé ã„';
        return 'é€šå¸¸è·é›¢';
      } else {
        const close = PARAMS.absCloseEnter, far = PARAMS.absFarEnter;
        if (!wasClose && z <= close) { wasClose = true; wasFar = false; return 'é¡”ãŒè¿‘ã„'; }
        if (!wasFar   && z >= far)   { wasFar   = true; wasClose = false; return 'é¡”ãŒé ã„'; }

        if (wasClose && z > close + band) { wasClose = false; }
        if (wasFar   && z < far   - band) { wasFar   = false; }

        if (wasClose) return 'é¡”ãŒè¿‘ã„';
        if (wasFar)   return 'é¡”ãŒé ã„';
        return 'é€šå¸¸è·é›¢';
      }
    }

    // â˜… combined(y+z) ã‚’è¿”ã™ï¼ˆã‚­ãƒ£ãƒªãƒ–æœ‰ç„¡ã«å¯¾å¿œï¼‰
    function getCombinedForDebug(){
      if (PARAMS.calibYdiff != null && PARAMS.calibNoseZ != null){
        return (sYdiff - PARAMS.calibYdiff) + (sNoseZ - PARAMS.calibNoseZ);
      }
      return (sYdiff ?? 0) + (sNoseZ ?? 0);
    }

    // â˜… æœ€çµ‚åˆ¤å®šï¼ˆç«¯æœ«è§’åº¦ã‚‚è€ƒæ…®ï¼‰
    function isBent(dir, prox, pitchAbs){
      if (prox === 'é¡”ãŒè¿‘ã„' && pitchAbs <= 30) return true;
      if (pitchAbs <= 40) return (dir === 'down' || dir === 'straight');
      return (dir === 'down');
    }

    // â˜… ä¿®æ­£ï¼šè¡¨ç¤ºã¯æ¯ãƒ•ãƒ¬ãƒ¼ãƒ åŒæœŸã€‚é¡”ãŒè¦‹ãˆã¦ã„ã‚Œã° bentState ã®å†…å®¹ã§å¸¸ã«ä¸Šæ›¸ãã€‚
    function updateSustain(isNow){
      const t = performance.now();
      let changed = false;

      if (isNow) {
        if (!bentState) {
          if (enterStart == null) enterStart = t;
          if (t - enterStart >= PARAMS.sustainMs) {
            bentState = true;
            exitStart = null;
            changed = true;
          }
        } else {
          exitStart = null;
        }
      } else {
        enterStart = null;
        if (bentState) {
          if (exitStart == null) exitStart = t;
          if (t - exitStart >= PARAMS.clearMs) {
            bentState = false;
            changed = true;
          }
        }
      }

      if (!faceDetected) {
        bentState = false;
        enterStart = exitStart = null;
        stopBeepLoop();
        setWarning(true, 'é¡”ãŒæ¤œå‡ºã§ãã¾ã›ã‚“');
        return;
      }

      if (bentState) {
        setWarning(true, 'é¦–ãŒæ›²ãŒã‚Šã™ãã¦ã„ã¾ã™ï¼ˆæ³¨æ„ï¼‰');
        startBeepLoop();
      } else {
        setWarning(false, 'å§¿å‹¢è‰¯å¥½ / è¨ˆæ¸¬ä¸­');
        stopBeepLoop();
      }
    }

    // ========== ãƒ­ã‚°ï¼ˆIndexedDBï¼‰ ==========
    const DB_NAME = 'posture-db';
    const DB_VERSION = 1;
    const STORE_NAME = 'logs';

    let db = null;
    let LOGGING = false;
    let lastLogTs = 0;

    function openDB(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = e => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
          }
        };
        req.onsuccess = e => { db = e.target.result; resolve(db); };
        req.onerror = e => reject(e.target.error);
      });
    }

    async function addLogSample(){
      if (!LOGGING) return;
      const now = Date.now();
      if (now - lastLogTs < 1000) return;
      lastLogTs = now;

      if (!db) await openDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const item = {
        ts: now,
        iso: new Date(now).toISOString(),
        pitch: sPitch,
        roll: sRoll,
        ydiff: sYdiff,
        noseZ: sNoseZ,
        dir: faceState.dir,
        prox: faceState.prox,
        bent: bentState
      };
      store.add(item);
    }

    async function getAllLogs(){
      if (!db) await openDB();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const req = store.getAll();
        req.onsuccess = e => resolve(e.target.result || []);
        req.onerror = e => reject(e.target.error);
      });
    }

    async function clearAllLogs(){
      if (!db) await openDB();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const req = store.clear();
        req.onsuccess = ()=>{ alert('ãƒ­ã‚°ã‚’å…¨å‰Šé™¤ã—ã¾ã—ãŸ'); resolve(); };
        req.onerror = e => reject(e.target.error);
      });
    }

    async function flushLogs(){
      // IndexedDB å†…ã«æºœã‚ã¦ã„ã‚‹ã ã‘ãªã®ã§ã€ç‰¹ã« flush ã¯ä¸è¦
      return;
    }

    async function exportCSV(){
      const logs = await getAllLogs();
      if (!logs.length){
        alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¯¾è±¡ã®ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“');
        return;
      }
      const header = [
        'id','time_iso','pitch_deg','roll_deg','ydiff','noseZ',
        'dir','prox','bent'
      ];
      const rows = [header.join(',')];
      logs.forEach((row, idx)=>{
        rows.push([
          idx+1,
          row.iso,
          row.pitch?.toFixed(4),
          row.roll?.toFixed(4),
          row.ydiff?.toFixed(6),
          row.noseZ?.toFixed(6),
          row.dir,
          row.prox,
          row.bent
        ].join(','));
      });
      const blob = new Blob([rows.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const stamp = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `posture_log_${stamp}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ========== ã‚­ãƒ£ãƒªãƒ–ï¼ˆä¿å­˜ãƒ»è§£é™¤ï¼‰ ==========
    function calibrate(){
      if (sYdiff == null || sNoseZ == null) {
        alert('ã¾ã å€¤ãŒå®‰å®šã—ã¦ã„ã¾ã›ã‚“ã€‚æ•°ç§’å¾…ã£ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
        return;
      }
      calibMode = true;
      calibSamples = [];
      calibStartTs = performance.now();
      setWarning(false, 'è‰¯ã„å§¿å‹¢ã§3ç§’é–“ãã®ã¾ã¾é™æ­¢ã—ã¦ãã ã•ã„');
    }

    function resetCalibration(){
      PARAMS.calibYdiff = null; PARAMS.calibNoseZ = null;
      localStorage.removeItem('posture-calib');
      setWarning(false, 'ã‚­ãƒ£ãƒªãƒ–ã‚’è§£é™¤ã—ã¾ã—ãŸ');
    }

    function saveCalibration(y, z){ try { localStorage.setItem('posture-calib', JSON.stringify({ y, z })); } catch {} }
    function loadCalibration(){ try { return JSON.parse(localStorage.getItem('posture-calib')); } catch { return null; } }

    // ========== åˆæœŸåŒ– ==========
    window.addEventListener('load', async ()=>{
      startBtn.addEventListener('click', ()=>{
        startBtn.disabled = true;
        calibBtn.disabled = false;
        resetBtn.disabled = false;
        startCamera();
        startSensor();
        initAudio();
        setWarning(false, 'è¨ˆæ¸¬ä¸­...');
      });

      calibBtn.addEventListener('click', calibrate);
      resetBtn.addEventListener('click', resetCalibration);

      const logStartBtn  = document.getElementById('logStartBtn');
      const logStopBtn   = document.getElementById('logStopBtn');
      const exportCsvBtn = document.getElementById('exportCsvBtn');
      const clearLogBtn  = document.getElementById('clearLogBtn');

      if (logStartBtn) logStartBtn.addEventListener('click', async ()=>{
        LOGGING = true;
        lastLogTs = 0;
        await flushLogs();
        // setWarning ã¯ä½¿ã‚ãªã„ï¼ˆè¡¨ç¤ºã‚’å£Šã•ãªã„ï¼‰
        output.textContent += '\n[LOG] ãƒ­ã‚°è¨˜éŒ²ã‚’é–‹å§‹ã—ã¾ã—ãŸ';
        logStartBtn.disabled = true; logStopBtn.disabled  = false;
      });

      if (logStopBtn) logStopBtn.addEventListener('click', async ()=>{
        LOGGING = false; await flushLogs();
        // setWarning ã¯ä½¿ã‚ãªã„ï¼ˆè¡¨ç¤ºã‚’å£Šã•ãªã„ï¼‰
        output.textContent += '\n[LOG] ãƒ­ã‚°è¨˜éŒ²ã‚’åœæ­¢ã—ã¾ã—ãŸ';
        logStartBtn.disabled = false; logStopBtn.disabled  = true;
      });

      if (exportCsvBtn) exportCsvBtn.addEventListener('click', exportCSV);
      if (clearLogBtn)  clearLogBtn.addEventListener('click', clearAllLogs);

      // â–¼ YouTube ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…ç·š â–¼
      const ytUrl = document.getElementById('ytUrl');
      const loadYtBtn = document.getElementById('loadYtBtn');
      const ytPlayer = document.getElementById('ytPlayer');

      function parseYouTube(url){
        if (!url) return null;
        try {
          const u = new URL(url);
          if (u.hostname.includes('youtu.be')) {
            return u.pathname.slice(1);
          }
          if (u.hostname.includes('youtube.com')) {
            if (u.searchParams.get('v')) {
              return u.searchParams.get('v');
            }
            const m = u.pathname.match(/\/embed\/([^/]+)/);
            if (m) return m[1];
          }
          return null;
        } catch {
          return null;
        }
      }

      if (loadYtBtn && ytUrl && ytPlayer){
        loadYtBtn.addEventListener('click', () => {
          const id = parseYouTube(ytUrl.value.trim());
          if (!id) {
            alert("URLã‚’æ­£ã—ãèªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ");
            return;
          }
          // éŸ³ä»˜ãè‡ªå‹•å†ç”Ÿã‚’è©¦ã™
          ytPlayer.src = `https://www.youtube.com/embed/${id}?autoplay=1&rel=0`;
        });
      }
    });
  </script>
</body>
</html>
